---

name: Модули
theory: |

  Система модулей в Racket похожа на подобные системы в других языках. Каждый файл обычно содержит ровно один модуль:

  ```scheme
  ; math.rkt
  #lang racket

  (define (sum a b) (+ a b))
  ```

  По умолчанию все объявления, сделанные в модуле, остаются внутри модуля. Импорт объявлений из других модулей (читай "файлов") происходит с помощью формы `require`:

  ```scheme
  (require "math.rkt")
  ```

  Однако, вы не сможете использовать объявления другого модуля, если модуль не экспортирует их явно. Для экспорта объявлений используется форма `provide`:

  ```scheme
  ; math.rkt
  #lang racket

  (provide sum)

  (define (sum a b) (+ a b))
  ```

  В `provide` перечисляются имена объявлений, которые нужно экспортировать. Любой другой модуль автоматически получает доступ ко всем экспортируемым объявлениям при импорте:

  ```scheme
  #lang racket

  (require "math.rkt")

  (define result (sum 5 3))
  ```

  При экспорте можно так же указать форму `(provide (all-defined-out))`. Таким обазом мы экспортируем *все объявления модуля*.

  Обратите внимание на следующие детали:

  * `require` работает с путями, ему можно передать как абсолютный так и относительный путь. В примере выше предполагается что оба модуля лежат в одной директории.

  * `require` автоматически делает доступным всё, что в импортируемом модуле указано в `provide`. Это бывает неудобно: во-первых, возможны конфликты имен, во-вторых, хочется явно понимать что откуда берется. Поэтому существует альтернативный способ вызова `require`:

  ```scheme
  (require (only-in "math.rkt" sum))
  ```

  `only-in` говорит что надо включить из модуля `"math.rkt"` переменную `sum` и больше ничего. Для включения дополнительных объявлений достаточно добавить их имена в конец списка.

instructions: |

  Экспортируйте объявление, которое есть в загруженном модуле

definitions: []
tips: []
