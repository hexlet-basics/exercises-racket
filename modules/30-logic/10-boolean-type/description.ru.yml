---

name: Логические операторы
theory: |

  True и False в Racket представлены значениями `#t` и `#f`. Запись непривычная, но в языках созданных много лет назад встречается и не такое. Большинство операций в Racket рассматривают как ложь только `#f`. Все остальное считается истиной. Пара примеров проверки на равенство:

  ```scheme
  (equal? 42 42) ; #t
  (equal? 42 24) ; #f
  ```

  Равенство значений проверяется через функцию `equal?`. Иногда может потребоваться сравнение по ссылке, в таком случае используют `eq?`.

  Напишем функцию `gt?`, которая возвращает `#t`, если первое число больше второго и `#f` в другом случае. В Racket имена предикатов заканчиваются вопросительным знаком. При этом к ним не добавляется префикс "is".

  ```scheme
  (define (gt? x y) (> x y))
  (gt? 3 2) ; #t
  (gt? 10 15) ; #f
  ```

  _Вот так разработчики на Ruby узнали почему в их языке предикаты выглядят как вопросы :)_

  Теперь напишем предикат, определяющий четность числа. Для этого нам понадобится функция `remainder`, которая вычисляет остаток от деления.

  ```scheme
  (define (even? n) (= (remainder n 2) 0))
  (even? 3) ; #f
  (even? 4) ; #t
  ```

  Логические операторы в Racket не имеют символьных обозначений, вместо этого используются функции `and`, `or`, `not` и другие.

  ```scheme
  (not "moon") ; #f
  (and (odd? 3) (even? 4)) ; #t
  ```

  Как и в случае с арифметическими операциями, мы получаем два бонуса:

  1. Префиксная нотация позволяет комбинировать любое число условий: `(and <one> <two> <three> <...>)`.
  1. Благодаря древовидной структуре исходного кода, приоритет всегда точно определен.

instructions: |

  Реализуйте функцию `same-parity?`, которая принимает на вход два числа и возвращает `#t` в том случае если их четность совпадает. В ином случае возвращается `#f`.

  ```scheme
  (same-parity? 3 7) ; #t
  (same-parity? 4 8) ; #t
  (same-parity? 4 7) ; #f
  (same-parity? 3 10) ; #f
  ```

tips: []
