---

name: Создание строк
theory: |

  Вы раньше встречались со строковыми литералами: `"hello"`, `"foo\nbar"`. Здесь Racket ничем не отличается от большинства других языков: строковые литералы могут содержать специальные символы вроде `\n`, символы Unicode вроде `\u03BB` и *экранированные* двойные кавычки `\"`.

  ```scheme
  (displayln "Bond, James\nCode name: \"007\"")
  ; => Bond, James
  ; => Code name: "007"
  ```

  Если же у нас есть строковые символы, то объединить их в строку можно с помощью функции `string`:

  ```scheme
  (define l #\l)
  (string #\H #\e l l #\o #\!) ; "Hello"
  (string)                     ; ""
  ```

  Когда нужно создать строку заданной длины, заполненную копиями некоторого символа, то подойдёт функция `make-string`:

  ```scheme
  (make-string 10 #\.) ; ".........."
  ```

  Длину созданной строки можно узнать с помощью функции `string-length`:

  ```scheme
  (string-length (string))             ; 0
  (string-length (make-string 10 #\!)) ; 10
  ```

  ### Строки и списки

  Как вы уже знаете, в Lisp многое строится вокруг списков. Вот и строки часто удобно обрабатывать именно как списки. Для этого используется пара функций `string->list` и `list->string`:

  ```scheme
  (string->list "ab") ; '(#\a #\b)
  (list->string null) ; ""
  (list->string (rest (string->list "Hello"))) ; "ello"
  ```

instructions: |

  Реализуйте функцию `next-chars`, которая создаёт новую строку на основе строки-аргумента таким образом, что каждый символ новой строки является "следующим" (с точки зрения кода) по отношению к соответствующему символу исходной строки.

  Примеры:

  ```scheme
  (next-chars "")      ; ""
  (next-chars "abc")   ; "bcd"
  (next-chars "12345") ; "23456"
  ```

tips: []
